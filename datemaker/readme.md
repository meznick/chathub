# datemaker
Сервис для менеджмента действий, связанных юзеров: регистрация на ивент,
подтверждение регистрации, создание ивентов, менеджмент звонков внутри ивента
и тд.

## Разработка
Используется python 3.10, зависимости из requirements.txt.
Для запуска сервиса нужно подложить файл с 
[кредами](#подключение-к-google-cloud-meet-api).

Запуск в локальном интерпретаторе:
```shell
# подготовить файл .env: положить куда удобно, в моем примере это будет корень
# домашней диры (~/).
# активируем файл с переменными окружения
source ~/.env
# запускаем модуль
python -m datemaker --debug # дебаг опционально
# при разработке может быть полезно запускать какие-то классы по отдельности,
# в т.ч. нужно написать тесты
```

Запуск в докере в разработке.

Запуск через модуль питона в разработке.

## Деплой
Пока не ясно как будет удобнее: писать отдельный dockerfile для каждого из сервисов
или создать универсальный контейнер и в нем запускать python модули, так что
попробуем и то и другое, выберем что больше понравится.

## Интеграция в проект

---
Нужно обновить terraform в соответствии с этим описанием.

---
Этот сервис читает сообщения из очереди "datemaker_prod/dev" в RabbitMQ и выполняет
запросы в соответствии с сообщениями. Возможна отправка сообщений в очередь
"bot_prod/dev": если нужно запросить подтверждение регистрации, отправить ссылку
на подключение к конференции в GMeet.

Нужно настроить мониторинг для прометеуса. Метрики:
- цпу, память
- количество сообщений в очереди на вход
- количество обработанных сообщений
- количество запланированных ивентов
- количество активных конференций/звонков

Нужно настроить запись данных по ивентам в бд для последующей аналитики?
- статистика зарегистрированных на ивент/принявших/отклонивших?
- действия юзеров во время ивента: что конкретно?

## Бизнес логика

### Регистрация на ивент
Регистрация на ивент инициализируется со стороны пользователя, через чат
(в перспективе через мини-аппку):
1. Юзеру показывается список ближайших ивентов (`bot.scenes.dating._display_main_menu`)
2. Он выбирает подходящий ему, отправляется запрос на регистрацию 
   (обработчик `bot.scenes.dating._handle_event_registration`)
3. После положительного ответа от datemaker, юзеру отправляется подтверждение
   (обработчик ответа `bot.data_handler.DataHandlerMixin.get_confirmation`)

### Подтверждение регистрации
За 24 часа до начала ивента нужно провести опрос зарегистрировавшихся,
они должны подтвердить участие.
Вся логика тут: `datemaker.service.RegistrationConfirmationRunner.handle_preparations`.
1. Собираем список участников
2. рассылаем запросы на подтверждение
3. Ждем пока получим все подтверждения, либо таймаута
4. Если участников набирается больше чем нужно для одного ивента, формируем группы.
   Внутри групп формируем пары юзеров по раундам.
5. Рассылаем уведомления о том что ивент состоится и памятку с правилами

### Создание новых ивентов
Для того чтобы было куда регистрировать пользователей, сервис должен заранее
по какому-то алгоритму создавать ивенты в определенное время. Пока никакой
умной логики я тут не придумал, так что пока ивенты создаются запросом в бд:
```sql
INSERT INTO public.dating_events (start_dttm)
VALUES ('2024-01-01'::TIMESTAMP); -- вручную вписываем время когда будет ивент
```

### Проведение ивента
На момент начала события уже должны быть готовы разбивка на дивизионы, разбивка
на пары.
Логика будет реализована тут: `datemaker.service.DateRunner.run_event`.

Сценарий ивента:
1. за 5 минут до назначенного времени всем участникам рассылается напоминалка с правилами
   ивента, с инструкцией как все будет проходить.
2. в целевое время (либо по истечении таймера для опаздывающих)
   всем участникам скидываются корректные ссылки на их звонки в мите
3. каждые пять минут звонок в мите принудительно завершается
4. пауза 1 мин чтобы участники перекурили + записали что-то про партнера
5. высылается ссылка на созвон с новым партнером, с этого места п.3-5 повторяются
   до тех пор пока все друг с другом не заобщаются
6. подведение итогов -- выбор партнеров. конкретная механика пока под вопросом.

### Возможные статусы ивента
Все возможные статусы перечислены в таблице `public.event_states`.
```
+--+-----------+
|id|state_name |
+--+-----------+
|0 |NOT_STARTED| -- событие создано
|1 |REG_CONFIRM| -- запущен процесс запроса подтверждений
|2 |READY      | -- ожидает времени для запуска
|3 |RUNNING    | -- в процессе
|4 |FINISHED   | -- завершен, данные сохранены
+--+-----------+
```

### Сохранение итогов ивента
Для улучшения системы рейтинга и обработки жалоб полезно сохранять "лог" дейтов.
Логика должна быть реализована тут: `datemaker.service.DateRunner.save_event_results`.

Свериться с [документацией](https://developers.google.com/meet/api/guides/artifacts)
GMeet для выявления того что мы можем сохранять и продумать как мы это будем
использовать. Так же, нужно понять можем ли мы сохранять события прямо во время
ивента (хватит ли ресурсов), или получится запускать этот пайплайн сразу после
окончания ивента.

### Подключение к Google Cloud (Meet API)
Подключение происходит по 
[документации](https://developers.google.com/meet/api/guides/quickstart/python),
таким образом в дире /datemaker должно находиться 2 файла: `creds.json` + 
`token.json`. Постарайся их не добавить в гит, а то придется поебаться, но так-то
они добавлены в gitignore.

### Формат сообщений в RabbitMQ
Каждое сообщение содержит заголовок с полями:
- user_id - юзер для которого вызывается команда / пришли данные
- chat_id - чат в котором нужны данные
- message_id - сообщение которое нужно будет отредактировать

Сообщения могут быть двух видов: команды и данные.
Сейчас возможные команды date maker перечислены в 
`chathub_bot/bot/__init__.py:24` и `datemaker/datemaker/__init__.py:22`.
Данные должны представлять собой json.
[Пример](https://github.com/meznick/chathub/blob/0c20fb6ac3e50d8baede783df0bc452a577802fe/datemaker/datemaker/service.py#L170)

[Пример](https://github.com/meznick/chathub/blob/0c20fb6ac3e50d8baede783df0bc452a577802fe/datemaker/datemaker/service.py#L119-L141) 
обработки комманд.

Механизм обработки данных:
1. При отправке команды через брокер создается запись в DataHandler о том что
ожидается обработка данных по ключу чат+сообщение.
2. При чтении новых сообщений в брокере, они обрабатываются в соответствии с
созданными записями.
3. После обработки запись в DataHandler удаляется.
